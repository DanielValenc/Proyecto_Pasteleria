from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
import httpx
from b2sdk.v2 import InMemoryAccountInfo, B2Api
from io import BytesIO

app = FastAPI()

# Configuración de la API externa
API_URL = "https://cloud.leonardo.ai/api/rest/v1/generations"
API_KEY = "57c8daa0-ec4e-4997-9f9c-73399336062a"

# Configuración de Backblaze B2
B2_KEY_ID = "0057a8127d9f9f30000000001"
B2_APPLICATION_KEY = "K005pRjlU3f/QjlwXFI9xes6lvEtbKM"
BUCKET_NAME = "Imagenes-G5"

# Inicializa la API de Backblaze
info = InMemoryAccountInfo()
b2_api = B2Api(info)
b2_api.authorize_account("production", B2_KEY_ID, B2_APPLICATION_KEY)
bucket = b2_api.get_bucket_by_name(BUCKET_NAME)

# Modelo para la solicitud de personalización
class CakeCustomizationRequest(BaseModel):
    personalizacion: str
    sabores: str
    forma: str
    adornos: str

@app.post("/generate-cake-image/")
async def generate_cake_image(request: CakeCustomizationRequest):
    """
    Crea un prompt basado en las características del pastel, solicita la generación de la imagen,
    y obtiene un token de generación para usar luego con el check-status.
    """
    # Construir el prompt
    prompt = (
        f"Genera un pastel de {request.personalizacion} de sabor {request.sabores}, "
        f"con forma {request.forma} y decorado con {request.adornos}."
    )

    # Configuración del payload para la API externa
    payload = {
        "prompt": prompt,
        "modelId": "6bef9f1b-29cb-40c7-b9df-32b51c1f67d3",  # Reemplaza con el ID de modelo adecuado
        "width": 512,
        "height": 512,
    }
    headers = {
        "accept": "application/json",
        "authorization": f"Bearer {API_KEY}",
        "content-type": "application/json"
    }

    # Enviar la solicitud a la API externa
    async with httpx.AsyncClient() as client:
        response = await client.post(API_URL, json=payload, headers=headers)

    if response.status_code != 200:
        raise HTTPException(status_code=response.status_code, detail=response.text)

    # Obtener el resultado de la API
    result = response.json()
    # Acceder al generation_id dentro del objeto 'sdGenerationJob'
    generation_id = result.get("sdGenerationJob", {}).get("generationId")
    
    # Depuración en caso de que no se reciba el generation_id
    if not generation_id:
        raise HTTPException(status_code=500, detail=f"No se recibió el generation_id. Respuesta: {result}.")

    # Retornar el generation_id para usar en el check-status
    return {"generation_id": generation_id}

@app.get("/check-status/{generation_id}")
async def check_status(generation_id: str):
    """
    Consulta el estado de una generación de imagen usando el generation_id
    y descarga las imágenes generadas desde las URLs.
    """
    url = f"{API_URL}/{generation_id}"
    headers = {
        "authorization": f"Bearer {API_KEY}"
    }

    async with httpx.AsyncClient() as client:
        response = await client.get(url, headers=headers)

    if response.status_code != 200:
        raise HTTPException(status_code=response.status_code, detail=response.text)

    # Obtener la respuesta completa para depuración
    result = response.json()

    # Revisar toda la estructura de la respuesta para ver dónde está el estado y las imágenes
    generations_data = result.get("generations_by_pk", {})

    if not generations_data:
        raise HTTPException(status_code=500, detail="No se encontraron datos de generación.")

    # Verificar el estado de la generación
    status = generations_data.get("status")

    if not status:
        raise HTTPException(status_code=500, detail="No se encontró el estado de la generación.")

    if status != "COMPLETE":
        raise HTTPException(status_code=500, detail=f"Generación en proceso. Estado actual: {status}")

    # Acceder a las imágenes generadas
    generated_images = generations_data.get("generated_images", [])
    if not generated_images:
        raise HTTPException(status_code=500, detail="No se encontraron imágenes generadas.")

    # Lista para guardar las URLs de las imágenes subidas
    uploaded_files = []

    # Iterar sobre las imágenes generadas y subirlas a Backblaze
    for idx, image in enumerate(generated_images):
        image_url = image.get("url")
        if not image_url:
            raise HTTPException(status_code=500, detail="No se encontró la URL de la imagen generada.")

        # Descargar la imagen desde la URL
        async with httpx.AsyncClient() as client:
            image_response = await client.get(image_url)

        if image_response.status_code != 200:
            raise HTTPException(status_code=image_response.status_code, detail="Error al descargar la imagen generada.")

        # Subir la imagen a Backblaze B2 con un nombre único
        file_name = f"pasteles/{generation_id}_image_{idx}.jpg"  # Usamos el generation_id y el índice para nombrar el archivo
        bucket.upload_bytes(image_response.content, file_name)

        # Guardar el nombre de archivo para referencia
        uploaded_files.append(file_name)

    # Generar el enlace público (aunque no es necesario mostrarlo)
    public_url = f"https://f002.backblazeb2.com/file/{BUCKET_NAME}/{uploaded_files[0]}"  # Mostramos solo el primero

    return {"message": "Imágenes generadas y almacenadas exitosamente.", "uploaded_files": uploaded_files}


@app.get("/")
async def read_root():
    return {"message": "Welcome to my FastAPI project!"}
